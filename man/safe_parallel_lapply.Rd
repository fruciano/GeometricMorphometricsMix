% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ancillary.R
\name{safe_parallel_lapply}
\alias{safe_parallel_lapply}
\title{Cross-platform safe parallel lapply}
\usage{
safe_parallel_lapply(
  X,
  FUN,
  ncores = (parallel::detectCores(logical = FALSE) - 1),
  packages = NULL,
  export = NULL,
  seed = NULL,
  type = c("auto", "mclapply", "psock")
)
}
\arguments{
\item{X}{A list or vector to iterate over.}

\item{FUN}{A function to apply to each element of \code{X}.}

\item{ncores}{Integer number of worker processes to use. Defaults to
\code{(parallel::detectCores(logical = FALSE)-1)} and is limited to
\code{length(X)}.}

\item{packages}{Character vector of package names to be required on the
worker processes (each worker will try to \code{require()} them).}

\item{export}{Character vector of names of objects in the current
environment to export to worker environments via \code{clusterExport}.}

\item{seed}{Optional integer seed for RNG on workers. When using PSOCK
clusters this is passed to \code{clusterSetRNGStream}; with forking
(mclapply) the seed is set via \code{set.seed()} on the master prior to
forking.}

\item{type}{One of \code{"auto"}, \code{"mclapply"} or \code{"psock"}
to force the backend selection. Default is \code{"auto"}.}
}
\value{
A \code{list} with the results of applying \code{FUN} to each
  element of \code{X} (same shape as \code{lapply}).
}
\description{
Select an appropriate parallel backend depending on the platform and run a
parallelized lapply safely. On Windows a PSOCK cluster is used
(parallel::parLapply). On Unix-like systems the function will try
to use forking via parallel::mclapply and will fall back to a PSOCK
cluster if forking is not available or fails. If \code{ncores == 1}
this simply calls \code{lapply}.
}
\details{
This function is used internally by a few functions in this package but is exported
so that users can reuse it for lightweight cross-platform parallel
work (for example on Windows where forking is not available).
}
\examples{
\dontrun{
# simple usage
safe_parallel_lapply(1:4, function(i) i^2, ncores = 2)

# more complex example: simulate work with a pause to compare serial vs parallel timing
slow_task = function(i) {
  # simulate a time-consuming operation (0.5 seconds)
  Sys.sleep(0.5)
  return(i^2)
}

# run serially (ncores = 1)
t_serial = system.time({
  res_serial = safe_parallel_lapply(1:8, slow_task, ncores = 1)
})

# run in parallel (ncores = 4)
t_parallel = system.time({
  res_parallel = safe_parallel_lapply(1:8, slow_task, ncores = 4)
})

# show timings
print(t_serial)    # expected ~ 4 seconds (8 * 0.5)
print(t_parallel)  # expected substantially less on a 4-core machine

# verify results are identical
identical(unlist(res_serial), unlist(res_parallel))
}
}
