% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/quantify_parallelism.R
\name{quantify_parallelism}
\alias{quantify_parallelism}
\title{Quantify and test for parallelism in multivariate vectors}
\usage{
quantify_parallelism(X, test = TRUE, ndim = ncol(X))
}
\arguments{
\item{X}{A matrix where each row represents a multivariate vector}

\item{test}{Logical. If TRUE, performs statistical tests for vector concentration (default: TRUE)}

\item{ndim}{Number of dimensions in the vector space (default: number of columns in X)}
}
\value{
A list containing:
- `C`: Correlation matrix
- `eigen_C`: Eigendecomposition of the correlation matrix
- `A`: Transformation matrix
- `prop_v`: Proportion of variance explained by first eigenvalue
- `var_eigenval_C`: Variance of eigenvalues
- `Schott_test`: Schott's test results for vector concentration
- `Rayleigh_test`: Rayleigh test results for vector concentration
}
\description{
Computes various metrics to quantify parallelism among multivariate vectors,
including vector correlations, eigenvalue analysis, and statistical tests.
}
\details{
The function largely follows the approaches outlined in De Lisle & Bolnick (2020)
and Watanabe (2022), whereas the Cramer's V-type scaling
for the Rayleigh test statistic is presented in Fruciano, Franchini et al. in preparation.
Specifically, the Schott test (Schott 2005) and the Rayleigh test (Mardia & Jupp 1999)
are discussed estensively in Watanabe (2022).
}
\examples{

# In this example we will create multivariate data for four random groups
# (we could imagine this is morphometric data for four populations)
# and we will test whether the difference between groups A and B is parallel
# to the difference between groups C and D.

set.seed(123)
library(MASS)
X=as.data.frame(mvrnorm(100, mu=rep(0, 50), Sigma=diag(50)))
# Create a matrix of 100 observations from a multivariate normal distribution
split_fac=as.factor(rep(c("A", "B", "C", "D"), each=25))
# Create a factor with 4 levels representing 4 hypothetical groups
X_split=split(X, f=split_fac)
# split the dataset based on the factor
X_means=do.call("rbind", lapply(X_split, colMeans))
# Compute vectors of average for each group
# (notice that, as we obtained random data and we are splitting into
# 4 random groups, we do not expect parallelism between the vectors)
#
# Now let us compute vectors of differences between the average of groups in pairs
X_diffs=rbind((X_means[1,]-X_means[2,]), (X_means[3,]-X_means[4,]))
# Notice that each row is a vector of differences

QP=quantify_parallelism(X_diffs)
# Run the function to quantify parallelism
# Checking the results, it will become clear how the vectors are not parallel
# This can be seen, for example, by looking at the p values for the Schott and Rayleigh tests

}
\references{
De Lisle, S. P., Bolnick, D.I. 2020. A multivariate view of parallel evolution. Evolution 74(7): 1466-1481.

Watanabe, J. 2022. Detecting (non)parallel evolution in multidimensional spaces: angles, correlations and eigenanalysis. Biology Letters 18(2):20210638.

Fruciano, Franchini et al. in preparation. Limited genetic parallelism underlies repeated sympatric divergence in Nicaraguan cichlid fish.

Mardia, K. V. and P. E. Jupp (1999). Directional Statistics.

Schott, J. R. 2005. Testing for complete independence in high dimensions. Biometrika 92(4): 951-956.
}
